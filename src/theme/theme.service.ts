import { BadRequestException, ConflictException, Injectable } from '@nestjs/common';
import { ThemeEntity } from './entity/theme.entity';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm';
import { ThemeDTO } from './dto/theme.dto';
import { UserEntity } from 'src/user/entity/user.entity';
import { GradeService } from 'src/grade/grade.service';
import { GradeEntity } from 'src/grade/entity/grade.entity';


@Injectable()
export class ThemeService {
    constructor(@InjectRepository(ThemeEntity) private readonly themeRepository: Repository<ThemeEntity>,
        private readonly dataSource: DataSource,
        private readonly gradeService: GradeService,
    ){}

    async find(themeId: string): Promise<ThemeEntity | null>{
        const theme = await this.themeRepository.findOne({where: {id: themeId}});
        
        return theme;
    } 

    async isExist(themeId: string): Promise<Boolean> {
        const isExist = !!(await this.themeRepository.findOne({where:{id: themeId}, select: {id: true}}));

        return isExist;
    }

    async isExistByTitle(title: string): Promise<Boolean> {
        const isExist = !!(await this.themeRepository.findOne({where:{title}, select: {title: true}}));

        return isExist;
    }

    async create(theme: ThemeDTO){
        const {title, maxPoints, isAutoGenerated} = theme;
        const isExist = await this.isExistByTitle(title);

        if(isExist){
            throw new ConflictException('Theme with this title already exist');
        }

        const entity = this.themeRepository.create({
            title,
            maxPoints,
            isAutoGenerated: !!isAutoGenerated,
        });

        try{
            await this.themeRepository.save(entity);
        }
        catch(err){
            throw new BadRequestException('Something went wrong');
        }

        return;
    }

    async getUserThemes(passport) {
        return await this.themeRepository
            .createQueryBuilder('theme')
            .leftJoinAndSelect('theme.grade', 'grade')
            .leftJoinAndSelect('grade.user', 'user')
            .where('user.id = :id', { id: passport })
            .select([
                'theme.id',
                'theme.title',
                'grade.grade',
            ])
            .getMany();
    }

    async get(passport: string){
        const themes = await this.themeRepository.find({select: {id: true}});
        let userThemes = await this.getUserThemes(passport);

        if(themes.length > userThemes.length){
            const missing = themes.filter((val) => {return !userThemes.find((userVal) => val.id === userVal.id)});
            await this.loadGrades(passport, missing);
            console.log('What wrong with you man')
            userThemes = await this.getUserThemes(passport);
        }
        
        let formedData = userThemes.map((val) => {
            const {title, id, grade} = val;

            return {title, id, grade: grade[0].grade};
        });
        return formedData;
    }

    async getGradeSection(theme: string, passport: string): Promise<number | null>{

        const themeData = await this.find(theme);
        const grade: number | undefined = await this.gradeService.getGrade(passport, theme);

        if(!themeData || grade === undefined){
            return null;
        }
        
        const gradeSection = [themeData.maxPoints * 0.2, themeData.maxPoints * 0.5, themeData.maxPoints * 0.84];

        const section: number = gradeSection.findIndex((val, index, obj) => (obj[index-1] | 0) <= grade && grade < val);

        console.log(`Section on gradeSection calculating: ${section}`)

        return section === -1? gradeSection.length-1: section;
    }

    async getGrade(theme: string, passport: string): Promise<number>{
        const grade: number | undefined = await this.gradeService.getGrade(passport, theme);

        return !!grade? grade: 0;
    }

    async loadDefaultGrades(passport: string): Promise<boolean>{
        const themes: ThemeEntity[] = await this.themeRepository.find({select: {id: true}});
        
        return await this.dataSource.transaction(async (manager) => {
            try{
                const grades = await Promise.all(
                    themes.map(theme => this.gradeService.create(passport, theme))
                );
                manager.save(grades);
            }
            catch{
                return false
            }

            return true;
        });

    }
    async loadGrades(passport: string, themes: ThemeEntity[]){
        return await this.dataSource.transaction(async (manager) => {
            try{
                const grades = await Promise.all(
                    themes.map(theme => this.gradeService.create(passport, theme))
                );
                manager.save(grades);
            }
            catch{
                return false
            }

            return true;
        });
    }

    async getAll(){
        //Добавить выборку, возвращать всё в виде одноуровнего объекта.
        return await this.themeRepository.find();
    }
}
